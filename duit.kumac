MACRO start  vec/create xp(2)  vec/create yp(2)  application comis end-of-comis      subroutine gen      vector bl(4)      vector br(4)      vector tc(4)      vector bf(4)      real rndm      integer intersect      real s1,s2C      C      bl(1) = int(100.0*RNDM(0)-50.0)C      bl(2) = int(100.0*RNDM(1)-50.0)      bl(1) = -20      bl(2) = 0.010    bl(3) = int(100.0*RNDM(2)-50.0)      if (bl(3).eq.bl(1)) goto 1011    bl(4) = int(100.0*RNDM(3)-50.0)      if (bl(4).eq.bl(2)) goto 11      if (bl(4).lt.bl(2).and.bl(3).gt.bl(1)) goto 10C      C      br(1) = int(100.0*RNDM(4)-50.0)C      br(2) = int(100.0*RNDM(5)-50.0)      br(1) = 20      br(2) = 0.020    br(3) = int(100.0*RNDM(6)-50.0)      if (br(3).eq.br(1)) goto 2021    br(4) = int(100.0*RNDM(7)-50.0)      if (br(4).eq.br(2)) goto 21      if (br(4).lt.br(2).and.br(3).lt.br(1)) goto 20C      bf(1) = bl(1)      bf(2) = bl(2)      bf(3) = br(1)      bf(4) = br(2)C      32    tc(1) = int(100.0*RNDM(8)-50.0)      tc(2) = int(100.0*RNDM(9)-50.0)30    tc(3) = int(100.0*RNDM(10)-50.0)      if (tc(3).eq.tc(1)) goto 3031    tc(4) = int(100.0*RNDM(11)-50.0)      if (tc(4).eq.tc(2)) goto 31C      if (intersect(tc,bf,s1,s2).eq.0) then        if (s1.gt.0.0.and.s1.lt.1.0.and.     +      s2.gt.0.0.and.s2.lt.1.0      ) goto 32      endifC      return      endCC      subroutine cover      vector bl(4)      vector br(4)      vector tc(4)      vector seen(4)      real lo, hiC      integer seenmeC      if (seenme(bl,br,tc,lo,hi).ne.0) then        if (lo.gt.1.0.or.hi.lt.0.0) then          seen(1) = -999        else          if (lo.lt.0.0) lo = 0.0          if (hi.gt.1.0) hi = 1.0          seen(1) = tc(1) + lo*(tc(3)-tc(1))          seen(2) = tc(2) + lo*(tc(4)-tc(2))          seen(3) = tc(1) + hi*(tc(3)-tc(1))          seen(4) = tc(2) + hi*(tc(4)-tc(2))        endif      else        seen(1) = -999      endifC      return      endCC      integer function seenme(bl,br,tc,lo,hi)      real bl(4),br(4),tc(4),lo,hiC      real sb,fc(4),cs1,cs2,ce1,ce2,fo(4),si      logical rout,lout,sokayC      integer intersect      real    crossout, crossover, oblique      logical sin,einC      fc(1) = bl(1)      fc(2) = bl(2)      fc(3) = br(1)      fc(4) = br(2)C      fo(1) = fc(3)      fo(2) = fc(4)      fo(3) = fc(1)      fo(4) = fc(2)CC     --- Check starting point and left blockC      c1 = crossout(bl,tc(1))      c2 = crossout(fc,tc(1))C      if (oblique(bl,fc).gt.0) thenCC       --- The left block is "oblique". C        if (c1.gt.0.and.c2.lt.0) then          lo = 1        else          lo = 0        endif      else        if (c1.gt.0.or.c2.lt.0) then          lo = 1        else          lo = 0        endif      endifC      if (lo.eq.1) thenCC       --- End point is outside: check intersectionC        if (intersect( bl, tc, sb, lo ).ne.0) then          write(6,*) 'Parallel left?'          goto 90        endif        if (sb.lt.0) then          write(6,*) 'Left in front'          goto 90        endif      endifCC     --- Check ending point and right blockC      c1 = crossout(br,tc(3))      c2 = crossout(fc,tc(3))C      if (oblique(br,fc).gt.0) thenCC       --- The right block is "oblique". C        if (c1.lt.0.and.c2.lt.0) then          hi = 0        else          hi = 1        endif      else        if (c1.lt.0.or.c2.lt.0) then          hi = 0        else          hi = 1        endif      endifC      if (hi.eq.0) thenCC       --- End point is outside: check intersectionC        if (intersect( br, tc, sb, hi ).ne.0) then          write(6,*) 'Parallel left?'          goto 90        endif        if (sb.lt.0) then          write(6,*) 'Right in front'          goto 90        endif      endifC      WRITE(6,*) 'LH: ', Lo, HiC      if (lo.ge.hi) then        write(6,*) 'Lo >= hi'        goto 90      endifC      seenme = 1      return90    seenme = 0      return      endCC      real function dot(l1,l2)      real l1(4),l2(4)C      dot = (l1(3)-l1(1))*(l2(3)-l2(1)) +      +      (l1(4)-l1(2))*(l2(4)-l2(2))      return      endCC      real function crossout(l1,xt)      real l1(4),xt(2)C      real da(2),db(2)C      da(1) = l1(3)-l1(1)      da(2) = l1(4)-l1(2)C      db(1) = xt(1)-l1(1)      db(2) = xt(2)-l1(2)C      crossout = da(1)*db(2)-da(2)*db(1)      return      endCC      real function oblique(l1,l2)      real l1(4),l2(4)C      real da(2),db(2)C      da(1) = l1(3)-l1(1)      da(2) = l1(4)-l1(2)C      db(1) = l2(3)-l2(1)      db(2) = l2(4)-l2(2)C      oblique = da(1)*db(2)-da(2)*db(1)      return      endCC      integer function intersect(l1,l2,s1,s2)      real l1(4),l2(4),s1,s2C      real t1(2),t2(2),dx(2)C      t1(1) = l1(3)-l1(1)      t1(2) = l1(4)-l1(2)C      t2(1) = l2(3)-l2(1)      t2(2) = l2(4)-l2(2)C      dx(1) = l1(1)-l2(1)      dx(2) = l1(2)-l2(2)C      div = t1(1)*t2(2) - t1(2)*t2(1)      if (abs(div).le.1E-6) then        intersect = 1        return      endifC      s1 = (dx(2)*t2(1) - dx(1)*t2(2))/div      s2 = (t1(1)*dx(2) - t1(2)*dx(1))/divC      intersect = 0      return      endend-of-comisRETURNMACRO testem  call gen  call cover  exec drawRETURNMACRO draw  null -55 55 -55 55  smk 20  set ksiz 0.1    arrow bl(1) bl(3) bl(2) bl(4) 0.3  arrow br(1) br(3) br(2) br(4) 0.3  arrow bl(1) br(1) bl(2) br(2) 0.3    vec/copy bl(1) xp(1)  vec/copy br(1) xp(2)  vec/copy bl(2) yp(1)  vec/copy br(2) yp(2)  pmarker 2 xp yp    arrow tc(1) tc(3) tc(2) tc(4) 0.3    if (seen(1).gt.-999) then    set lwid 8    arrow seen(1) seen(3) seen(2) seen(4) 0.4  endif  smk  set ksiz  set lwidRETURN